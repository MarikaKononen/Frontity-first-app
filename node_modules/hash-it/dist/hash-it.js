(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.hashIt = {}));
}(this, function (exports) { 'use strict';

    /**
     * @constant __ placeholder used when parameters are skipped
     */
    var __ = typeof Symbol === 'function' ? Symbol('curriable placeholder') : 0xedd1;
    /**
     * @function recursiveCurry
     *
     * @description
     * recursively curry over the arguments until all have been resolved
     *
     * @param fn the function to curry
     * @param arity the length of the function to curry until
     * @param args the existing arguments
     * @returns the result of the function call
     */
    var recursiveCurry = function (fn, arity, args) {
        return function () {
            var length = args.length;
            var newArgs = arguments;
            var newArgsLength = newArgs.length;
            var combined = [];
            var newArgsIndex = 0;
            var remaining = arity;
            var value;
            if (length) {
                for (var index = 0; index < length; index++) {
                    value = combined[index] =
                        args[index] === __ && newArgsIndex < newArgsLength
                            ? newArgs[newArgsIndex++]
                            : args[index];
                    if (value !== __) {
                        --remaining;
                    }
                }
            }
            if (newArgsIndex < newArgsLength) {
                for (; newArgsIndex < newArgsLength; newArgsIndex++) {
                    value = newArgs[newArgsIndex];
                    combined.push(value);
                    if (value !== __ && newArgsIndex < arity) {
                        --remaining;
                    }
                }
            }
            return remaining > 0
                ? recursiveCurry(fn, arity, combined)
                : fn.apply(this, combined);
        };
    };

    // utils
    /**
     * @function curry
     *
     * @description
     * get the method passed as a curriable method based on its parameters
     *
     * @param fn the method to make curriable
     * @param arity the arity of the curried method
     * @returns the fn passed as a curried function
     */
    var curry = function (fn, arity) {
        if (arity === void 0) { arity = fn.length; }
        var curried = recursiveCurry(fn, arity, []);
        curried.arity = arity;
        curried.fn = fn;
        return curried;
    };
    curry.__ = __;
    /**
     * @function uncurry
     *
     * @description
     * return a function that is the non-curried version of the fn passed
     *
     * @param curried the curried function to uncurry
     * @returns the original fn
     */
    var uncurry = function (curried) { return curried.fn; };
    curry.uncurry = uncurry;

    /**
     * @function first
     *
     * @description
     * get the first n number of items from the array as a new array (faster than native splice)
     *
     * @param {Array<any>} array the array to get the items from
     * @param {number} length the length to limit the size to
     * @returns {Array<any>} the array limited in size
     */
    var first = function first(array, length) {
      var newArray = new Array(length);

      for (var index = 0; index < length; index++) {
        newArray[index] = array[index];
      }

      return newArray;
    };
    /**
     * @function getCircularValue
     *
     * @description
     * create a method that will get a placeholder for the circular value based
     * on the value saved in the cache for it
     *
     * @param {any} key the key of the object to stringify
     * @param {any} value the value of the object at key
     * @param {number} refCount the index of the ref
     * @returns {string} the circular value
     */

    var getCircularValue = function getCircularValue(key, value, refCount) {
      return "[ref-" + refCount + "]";
    };
    /**
     * @function indexOf
     *
     * @description
     * get the index of the value in the array (faster than native indexOf)
     *
     * @param {Array<any>} array the array to get the index of the value at
     * @param {any} value the value to match
     * @returns {number} the index of the value in array
     */

    var indexOf = function indexOf(array, value) {
      for (var index = 0; index < array.length; index++) {
        if (array[index] === value) {
          return index;
        }
      }

      return -1;
    };
    /**
     * @function createReplacer
     *
     * @description
     * create a replacer method that handles circular values
     *
     * @param {function} [replacer] a custom replacer to use for non-circular values
     * @param {function} [circularReplacer] a custom replacer to use for circular methods
     * @returns {any} the value to stringify
     */

    var createReplacer = function createReplacer(replacer, circularReplacer) {
      var getCircularReplacer = circularReplacer || getCircularValue;
      var hasReplacer = typeof replacer === 'function';
      var cache = [],
          locationOfThis,
          locationOfValue;
      return function (key, value) {
        if (cache.length) {
          locationOfThis = indexOf(cache, this);

          if (~locationOfThis) {
            cache = first(cache, locationOfThis + 1);
          } else {
            cache[cache.length] = this;
          }

          locationOfValue = indexOf(cache, value);

          if (~locationOfValue) {
            return getCircularReplacer.call(this, key, value, locationOfValue);
          }
        } else {
          cache[0] = value;
        }

        return hasReplacer ? replacer.call(this, key, value) : value;
      };
    };

    // utils
    /**
     * @function stringify
     *
     * @description
     * strinigifer that handles circular values
     *
     * @param {any} value the value to stringify
     * @param {function} [replacer] a custom replacer function for stringifying standard values
     * @param {number} [indent] the number of spaces to indent the output by
     * @param {function} [circularReplacer] a custom replacer function for stringifying circular values
     * @returns {string} the stringified output
     */

    function stringify(value, replacer, indent, circularReplacer) {
      return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
    }

    var _SELF_TAGS, _TOSTRING_TAGS, _TYPEDARRAY_TAGS, _UNPARSEABLE_TAGS;

    /**
     * @constant {string} CIRCULAR_VALUE
     */
    var CIRCULAR_VALUE = '~';
    /**
     * @constant {boolean} HAS_BUFFER_FROM_SUPPORT
     */

    var HAS_BUFFER_FROM_SUPPORT = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
    /**
     * @constant {boolean} HAS_UINT16ARRAY_SUPPORT
     */

    var HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';
    /**
     * @constant {RegExp} HTML_ELEMENT_REGEXP
     */

    var HTML_ELEMENT_REGEXP = /\[object (HTML(.*)Element)\]/;
    /**
     * @constant {RegExp} SVG_ELEMENT_REGEXP
     */

    var SVG_ELEMENT_REGEXP = /\[object (SVG(.*)Element)\]/;
    /**
     * @constant {Array<string>} OBJECT_CLASSES
     */

    var OBJECT_CLASSES = ['Arguments', 'Array', 'ArrayBuffer', 'Boolean', 'DataView', 'Date', 'DocumentFragment', 'Error', 'Event', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction', 'HTMLElement', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Null', 'Number', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'Undefined', 'WeakMap', 'WeakSet', 'Window'];
    /**
     * @constant {Object} OBJECT_CLASS_MAP
     */

    var OBJECT_CLASS_MAP = OBJECT_CLASSES.reduce(function (objectClasses, type) {
      objectClasses["[object " + type + "]"] = type;
      return objectClasses;
    }, {});
    /**
     * @constant {Object} OBJECT_CLASS_TYPE_MAP
     */

    var OBJECT_CLASS_TYPE_MAP = Object.keys(OBJECT_CLASS_MAP).reduce(function (objectClassTypes, objectClass) {
      objectClassTypes[OBJECT_CLASS_MAP[objectClass].toUpperCase()] = objectClass;
      return objectClassTypes;
    }, {});
    var ITERABLE_TAGS = {
      '[object Map]': true,
      '[object Set]': true
    };
    var PRIMITIVE_TAGS = {
      boolean: true,
      function: true,
      number: true,
      string: true,
      undefined: true
    };
    var SELF_TAGS = (_SELF_TAGS = {}, _SELF_TAGS[OBJECT_CLASS_TYPE_MAP.ARGUMENTS] = true, _SELF_TAGS[OBJECT_CLASS_TYPE_MAP.ARRAY] = true, _SELF_TAGS);
    var TOSTRING_TAGS = (_TOSTRING_TAGS = {}, _TOSTRING_TAGS[OBJECT_CLASS_TYPE_MAP.REGEXP] = true, _TOSTRING_TAGS[OBJECT_CLASS_TYPE_MAP.SYMBOL] = true, _TOSTRING_TAGS);
    var TYPEDARRAY_TAGS = (_TYPEDARRAY_TAGS = {}, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.FLOAT32ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.FLOAT64ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT8ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT16ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.INT32ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT8ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT8CLAMPEDARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT16ARRAY] = true, _TYPEDARRAY_TAGS[OBJECT_CLASS_TYPE_MAP.UINT32ARRAY] = true, _TYPEDARRAY_TAGS);
    var UNPARSEABLE_TAGS = (_UNPARSEABLE_TAGS = {}, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.GENERATOR] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.PROMISE] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.WEAKMAP] = true, _UNPARSEABLE_TAGS[OBJECT_CLASS_TYPE_MAP.WEAKSET] = true, _UNPARSEABLE_TAGS);

    // external dependencies
    var charCodeAt = String.prototype.charCodeAt;
    var toString = Object.prototype.toString;
    var keys = Object.keys;
    /**
     * @function getFunctionName
     *
     * @description
     * get the name of the function based on a series of fallback attempts
     *
     * @param {function} fn the function to test
     * @returns {string} the function name
     */

    var getFunctionName = function getFunctionName(fn) {
      return fn.name || (fn.toString().match(/^\s*function\s*([^\(]*)/i) || [])[1] || 'anonymous';
    };
    /**
     * @function getCircularValue
     *
     * @description
     * get the value used when circular references are found
     *
     * @returns {string} the value for stringification
     */

    var getCircularValue$1 = function getCircularValue() {
      return CIRCULAR_VALUE;
    };
    /**
     * @function getIntegerHashValue
     *
     * @description
     * based on string passed, get the integer hash value
     * through bitwise operation (based on spinoff of dbj2
     * with enhancements for reduced collisions)
     *
     * @param {string} string the string to get the hash value for
     * @returns {number} the hash value
     */

    var getIntegerHashValue = function getIntegerHashValue(string) {
      var index = string.length,
          hashA = 5381,
          hashB = 52711,
          charCode;

      while (index--) {
        charCode = charCodeAt.call(string, index);
        hashA = hashA * 33 ^ charCode;
        hashB = hashB * 33 ^ charCode;
      }

      return (hashA >>> 0) * 4096 + (hashB >>> 0);
    };
    /**
     * @function getSortedEvent
     *
     * @description
     * get the event object sorted by its properties
     *
     * @param {boolean} bubbles does the event bubble up through the DOM
     * @param {function} alias to stopPropagation
     * @param {boolean} cancelable is the event cancelable
     * @param {boolean} composed can the event bubble across the boundary to shadow DOM
     * @param {HTMLElement} [currentTarget] registered target for the event
     * @param {boolean} defaultPrevented has preventDefault been called on the event
     * @param {string} eventPhase the phase of the event flow being processed
     * @param {boolean} isTrusted was the event initiated by the browser
     * @param {HTMLElement} [target] the target with which the event was dispatched
     * @param {number} timeStamp the time at which the event was created
     * @param {string} type the name of the event
     * @returns {Object} the event object with all properties sorted
     */

    var getSortedEvent = function getSortedEvent(_ref) {
      var bubbles = _ref.bubbles,
          cancelBubble = _ref.cancelBubble,
          cancelable = _ref.cancelable,
          composed = _ref.composed,
          currentTarget = _ref.currentTarget,
          defaultPrevented = _ref.defaultPrevented,
          eventPhase = _ref.eventPhase,
          isTrusted = _ref.isTrusted,
          returnValue = _ref.returnValue,
          target = _ref.target,
          type = _ref.type;
      return {
        bubbles: bubbles,
        cancelBubble: cancelBubble,
        cancelable: cancelable,
        composed: composed,
        currentTarget: currentTarget,
        defaultPrevented: defaultPrevented,
        eventPhase: eventPhase,
        isTrusted: isTrusted,
        returnValue: returnValue,
        target: target,
        type: type
      };
    };
    /**
     * @function shouldSort
     *
     * @description
     * get the sort result based on the two values to compare
     *
     * @param {string} valueA the first value to compare
     * @param {string} valueB the second value to compare
     * @returns {boolean} should the value be sorted
     */

    var shouldSort = function shouldSort(valueA, valueB) {
      return valueA > valueB;
    };
    /**
     * @function shouldSortPair
     *
     * @description
     * get the sort result based on the two pairs to compare
     *
     * @param {Object} pairA the first pair to compare
     * @param {Object} pairB the second pair to compare
     * @returns {boolean} should the value be sorted
     */

    var shouldSortPair = function shouldSortPair(pairA, pairB) {
      return shouldSort(pairA[0], pairB[0]);
    };
    /**
     * @function getPrefixedValue
     *
     * @description
     * get the value prefixed by the tag
     *
     * @param {string} tag the object tag
     * @param {any} value the value to stringify
     * @returns {string} the prefixed stringified value
     */

    var getPrefixedValue = function getPrefixedValue(tag, value) {
      return tag + "|" + value;
    };
    /**
     * @function sort
     *
     * @description
     * sort the array based on the fn passed
     *
     * @param {Array<any>} array the array to sort
     * @param {function} fn the sorting function
     * @returns {Array<any>} the sorted array
     */

    var sort = function sort(array, fn) {
      var subIndex, value;

      for (var index = 0; index < array.length; index++) {
        value = array[index];

        for (subIndex = index - 1; ~subIndex && fn(array[subIndex], value); subIndex--) {
          array[subIndex + 1] = array[subIndex];
        }

        array[subIndex + 1] = value;
      }

      return array;
    };
    /**
     * @function getIterablePairs
     *
     * @description
     * get the pairs in the iterable for stringification
     *
     * @param {Map|Set} iterable the iterable to get the pairs for
     * @returns {Array<{key: string, value: any}>} the pairs
     */

    var getSortedIterablePairs = function getSortedIterablePairs(iterable) {
      var isMap = typeof iterable.get === 'function';
      var pairs = [];
      iterable.forEach(function (value, key) {
        // eslint-disable-next-line no-use-before-define
        pairs.push(isMap ? [stringify$1(key), stringify$1(value)] : [stringify$1(value)]);
      });
      sort(pairs, shouldSortPair);
      var finalPairs = new Array(iterable.size);
      var pair;

      for (var index = 0; index < iterable.size; index++) {
        pair = pairs[index];
        finalPairs[index] = isMap ? "[" + pair[0] + "," + pair[1] + "]" : pair[0];
      }

      return getPrefixedValue(getFunctionName(iterable.constructor), "[" + finalPairs.join(',') + "]");
    };
    /**
     * @function getSortedObject
     *
     * @description
     * get the object with the keys sorted
     *
     * @param {Object} object the object to sort
     * @returns {Object} the sorted object
     */

    var getSortedObject = function getSortedObject(object) {
      var objectKeys = sort(keys(object), shouldSort);
      var newObject = {};
      var key;

      for (var index = 0; index < objectKeys.length; index++) {
        key = objectKeys[index];
        newObject[key] = object[key];
      }

      return newObject;
    };
    /**
     * @function getStringifiedArrayBufferFallback
     *
     * @description
     * get the string value of the buffer passed based on a Buffer
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    var getStringifiedArrayBufferFallback = function getStringifiedArrayBufferFallback(buffer) {
      return String.fromCharCode.apply(null, new Uint16Array(buffer));
    };
    /**
     * @function getStringifiedArrayBufferModern
     *
     * @description
     * get the string value of the buffer passed based on a Uint16Array
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    var getStringifiedArrayBufferModern = function getStringifiedArrayBufferModern(buffer) {
      return Buffer.from(buffer).toString('utf8');
    };
    /**
     * @function getStringifiedArrayBufferNoSupport
     *
     * @description
     * return a placeholder when no arraybuffer support exists
     *
     * @returns {string} the placeholder
     */

    var getStringifiedArrayBufferNoSupport = function getStringifiedArrayBufferNoSupport() {
      return '';
    };
    /**
     * @function getStringifiedArrayBuffer
     *
     * @description
     * get the string value of the buffer passed
     *
     * @param {ArrayBuffer} buffer the array buffer to convert
     * @returns {string} the stringified buffer
     */

    var getStringifiedArrayBuffer = function () {
      if (HAS_BUFFER_FROM_SUPPORT) {
        return getStringifiedArrayBufferModern;
      }

      if (HAS_UINT16ARRAY_SUPPORT) {
        return getStringifiedArrayBufferFallback;
      }

      return getStringifiedArrayBufferNoSupport;
    }();
    /**
     * @function getStringifiedDocumentFragment
     *
     * @description
     * build a string based on all the fragment's children
     *
     * @param {DocumentFragment} fragment the fragment to stringify
     * @returns {string} the stringified fragment
     */

    var getStringifiedDocumentFragment = function getStringifiedDocumentFragment(fragment) {
      var children = fragment.children;
      var innerHTML = '';

      for (var index = 0; index < children.length; index++) {
        innerHTML += children[index].outerHTML;
      }

      return innerHTML;
    };
    /**
     * @function indexOf
     *
     * @description
     * get the index of the value in the array (faster than native indexOf)
     *
     * @param {Array<any>} array the array to get the index of the value at
     * @param {any} value the value to match
     * @returns {number} the index of the value in array
     */

    var indexOf$1 = function indexOf(array, value) {
      for (var index = 0; index < array.length; index++) {
        if (array[index] === value) {
          return index;
        }
      }

      return -1;
    };
    /**
     * @function getNormalizedValue
     *
     * @description
     * get the value normalized for stringification
     *
     * @param {any} value the value to normalize
     * @param {WeakMap|Object} sortedCache the cache of sorted objects
     * @param {string} [passedTag] the previously-calculated tag
     * @returns {any} the normalized value
     */

    var getNormalizedValue = function getNormalizedValue(value, sortedCache, passedTag) {
      if (passedTag === void 0) {
        var type = typeof value;

        if (type === 'string') {
          return value;
        }

        if (PRIMITIVE_TAGS[type]) {
          return getPrefixedValue(type, value);
        }

        if (value === null) {
          return getPrefixedValue('null', value);
        }
      }

      var tag = passedTag || toString.call(value);

      if (SELF_TAGS[tag]) {
        return value;
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.OBJECT) {
        if (~indexOf$1(sortedCache, value)) {
          return CIRCULAR_VALUE;
        }

        sortedCache.push(value);
        return getSortedObject(value, sortedCache);
      }

      if (TOSTRING_TAGS[tag]) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.toString());
      }

      if (ITERABLE_TAGS[tag]) {
        if (~indexOf$1(sortedCache, value)) {
          return CIRCULAR_VALUE;
        }

        sortedCache.push(value);
        return getSortedIterablePairs(value);
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DATE) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.getTime());
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.ERROR) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.stack);
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.EVENT) {
        return getSortedEvent(value);
      }

      if (UNPARSEABLE_TAGS[tag]) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], 'NOT_ENUMERABLE');
      }

      if (HTML_ELEMENT_REGEXP.test(tag) || SVG_ELEMENT_REGEXP.test(tag)) {
        return getPrefixedValue(tag.slice(8, -1), value.outerHTML);
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DOCUMENTFRAGMENT) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedDocumentFragment(value));
      }

      if (TYPEDARRAY_TAGS[tag]) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], value.join(','));
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.ARRAYBUFFER) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedArrayBuffer(value));
      }

      if (tag === OBJECT_CLASS_TYPE_MAP.DATAVIEW) {
        return getPrefixedValue(OBJECT_CLASS_MAP[tag], getStringifiedArrayBuffer(value.buffer));
      }

      return value;
    };
    /**
     * @function replacer
     *
     * @description
     * create the replacer function used for stringification
     *
     * @param {WeakSet|Object} sortedCache the cache to use for sorting objects
     * @returns {function(key: string, value: any)} function getting the normalized value
     */

    var createReplacer$1 = function createReplacer(sortedCache) {
      return function (key, value) {
        return getNormalizedValue(value, sortedCache);
      };
    };
    /**
     * @function stringify
     *
     * @description
     * stringify the value based on the options passed
     *
     * @param {any} value the value to stringify
     * @returns {string} the stringified value
     */

    function stringify$1(value) {
      if (!value || typeof value !== 'object') {
        return getNormalizedValue(value);
      }

      var tag = toString.call(value);
      return tag === OBJECT_CLASS_TYPE_MAP.DATE || tag === OBJECT_CLASS_TYPE_MAP.REGEXP ? getNormalizedValue(value, void 0, tag) : stringify(value, createReplacer$1([]), null, getCircularValue$1);
    }

    // external dependencies
    /**
     * @function hash
     *
     * @description
     * hash the value passed to a unique, consistent hash value
     *
     * @param {any} value the value to hash
     * @returns {number} the object hash
     */

    var hash = function hash(value) {
      return getIntegerHashValue(stringify$1(value));
    };
    /**
     * @function hash.is
     *
     * @description
     * create a comparator for the first object passed to determine if the second is equal
     *
     * @param {any} object the object to test against
     * @returns {function(any): boolean} the method to test against the object
     */

    hash.is = curry(function (object, otherObject) {
      return hash(object) === hash(otherObject);
    });
    /**
     * @function hash.is.all
     *
     * @description
     * determine if all of the objects passed are equal in value to the first
     *
     * @param {...Array<any>} objects the objects to test for equality
     * @returns {boolean} are the objects equal
     */

    hash.is.all = curry(function () {
      for (var _len = arguments.length, objects = new Array(_len), _key = 0; _key < _len; _key++) {
        objects[_key] = arguments[_key];
      }

      var isEqual = hash.is(objects.shift());

      for (var index = 0; index < objects.length; index++) {
        if (!isEqual(objects[index])) {
          return false;
        }
      }

      return true;
    }, 2);
    /**
     * @function hash.is.any
     *
     * @description
     * determine if any of the objects passed are equal in value to the first
     *
     * @param {...Array<any>} objects the objects to test for equality
     * @returns {boolean} are the objects equal
     */

    hash.is.any = curry(function () {
      for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        objects[_key2] = arguments[_key2];
      }

      var isEqual = hash.is(objects.shift());

      for (var index = 0; index < objects.length; index++) {
        if (isEqual(objects[index])) {
          return true;
        }
      }

      return false;
    }, 2);
    /**
     * @function hash.is.not
     *
     * @description
     * create a comparator for the first object passed to determine if the second is not equal
     *
     * @param {any} object the object to test against
     * @returns {function(any): boolean} the method to test against the object
     */

    hash.is.not = curry(function (object, otherObject) {
      return hash(object) !== hash(otherObject);
    });

    exports.hash = hash;
    exports.default = hash;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=hash-it.js.map
