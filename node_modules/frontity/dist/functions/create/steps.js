"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const path_1 = require("path");
const child_process_1 = require("child_process");
const util_1 = require("util");
const fs_extra_1 = require("fs-extra");
const tar_1 = require("tar");
const node_fetch_1 = __importDefault(require("node-fetch"));
const ramda_1 = require("ramda");
const utils_1 = require("../../utils");
const allowedExistingContent = ["readme.md", "license", ".git", ".gitignore"];
const faviconUrl = "https://favicon.frontity.org/";
// This function normalizes and validates options.
exports.normalizeOptions = (defaultOptions, passedOptions) => {
    const options = ramda_1.mergeRight(defaultOptions, passedOptions);
    // Normalize and validate `name` option.
    options.name = options.name.replace(/[\s_-]+/g, "-").toLowerCase();
    if (!utils_1.isPackageNameValid(options.name))
        throw new Error("The name of the package is not valid. Please enter a valid one (only letters and dashes).");
    return options;
};
// This function ensures the path and checks if it's empty or it's a new repo.
// Also returns a boolean indicating if the dir existed already.
exports.ensureProjectDir = async ({ path }) => {
    const dirExisted = await fs_extra_1.pathExists(path);
    if (dirExisted) {
        // Check if the directory is a new repo.
        const dirContent = await fs_extra_1.readdir(path);
        const notAllowedContent = dirContent.filter(content => !allowedExistingContent.includes(content.toLowerCase()));
        // If it's not, throw.
        if (notAllowedContent.length) {
            throw new Error("The directory passed to `create` function is not empty");
        }
    }
    else {
        await fs_extra_1.ensureDir(path);
    }
    return dirExisted;
};
// This function creates a `package.json` file.
exports.createPackageJson = async ({ name, theme, path }) => {
    const packages = [
        "frontity",
        "@frontity/core",
        "@frontity/wp-source",
        "@frontity/tiny-router"
    ];
    // Add Frontity packages to the dependencies.
    const dependencies = (await Promise.all(packages.map(async (pkg) => {
        // Get the version of each package.
        const response = await node_fetch_1.default(`https://registry.npmjs.com/${pkg}`);
        const data = await response.json();
        const version = data["dist-tags"].latest;
        return [pkg, `^${version}`];
    }))).reduce((final, current) => {
        // Reduce the packages into a dependecies object.
        final[current[0]] = current[1];
        return final;
    }, {});
    // Add the starter theme to the dependencies.
    const themeName = (theme.match(/\/?([\w-]+)$/) || [, ""])[1];
    dependencies[theme] = `./packages/${themeName}`;
    const packageJson = {
        name,
        version: "1.0.0",
        private: true,
        description: "Frontity project",
        keywords: ["frontity"],
        scripts: {
            dev: "frontity dev",
            build: "frontity build",
            serve: "frontity serve"
        },
        dependencies
    };
    const filePath = path_1.resolve(path, "package.json");
    const fileData = `${JSON.stringify(packageJson, null, 2)}${os_1.EOL}`;
    await fs_extra_1.writeFile(filePath, fileData);
};
// This function creates a `frontity.settings` file.
exports.createFrontitySettings = async (extension, { name, path }) => {
    const frontitySettings = {
        name,
        state: {
            frontity: {
                url: "https://test.frontity.io",
                title: "Test Frontity Blog",
                description: "WordPress installation for Frontity development"
            }
        },
        packages: [
            "@frontity/tiny-router",
            {
                name: "@frontity/mars-theme",
                state: {
                    theme: {
                        menu: [
                            ["Home", "/"],
                            ["Nature", "/category/nature/"],
                            ["Travel", "/category/travel/"],
                            ["Japan", "/tag/japan/"],
                            ["About Us", "/about-us/"]
                        ],
                        featured: {
                            showOnList: false,
                            showOnPost: false
                        }
                    }
                }
            },
            {
                name: "@frontity/wp-source",
                state: {
                    source: {
                        apiUrl: "https://test.frontity.io/wp-json"
                    }
                }
            }
        ]
    };
    const fileTemplate = await fs_extra_1.readFile(path_1.resolve(__dirname, `../../../templates/settings-${extension}-template`), { encoding: "utf8" });
    const filePath = path_1.resolve(path, `frontity.settings.${extension}`);
    const fileData = fileTemplate.replace(/\$([\w-]+)\$/g, (_match, key) => {
        if (key === "settings")
            return JSON.stringify(frontitySettings, null, 2);
    });
    await fs_extra_1.writeFile(filePath, fileData);
};
// This functions clones the starter theme.
exports.cloneStarterTheme = async ({ theme, path }) => {
    const packageJsonPath = path_1.resolve(path, "./package.json");
    const packageJson = JSON.parse(await fs_extra_1.readFile(packageJsonPath, { encoding: "utf8" }));
    const themePath = path_1.resolve(path, packageJson.dependencies[theme]);
    await fs_extra_1.ensureDir(themePath);
    if (!utils_1.isPackageNameValid(theme))
        throw new Error("The name of the theme is not a valid npm package name.");
    await util_1.promisify(child_process_1.exec)(`npm pack ${theme}`, { cwd: themePath });
    const tarball = (await fs_extra_1.readdir(themePath)).find(file => /\.tgz$/.test(file));
    const tarballPath = path_1.resolve(themePath, tarball);
    await tar_1.extract({ cwd: themePath, file: tarballPath, strip: 1 });
    await fs_extra_1.remove(tarballPath);
};
// This function installs the Frontity packages.
exports.installDependencies = async ({ path }) => {
    await util_1.promisify(child_process_1.exec)("npm install", { cwd: path });
};
// This function downlaods the favicon file.
exports.downloadFavicon = async ({ path }) => {
    await new Promise(async (resolve, reject) => {
        try {
            const response = await node_fetch_1.default(faviconUrl);
            const fileStream = fs_extra_1.createWriteStream(path_1.resolve(path, "favicon.ico"));
            response.body.pipe(fileStream);
            fileStream.on("finish", resolve);
        }
        catch (error) {
            reject(error);
        }
    });
};
// This function removes the files and directories created
// with `frontity create`.
exports.revertProgress = async (dirExisted, { path }) => {
    if (dirExisted) {
        const content = await fs_extra_1.readdir(path);
        const removableContent = content
            .filter(item => !allowedExistingContent.includes(item.toLowerCase()))
            .map(item => path_1.resolve(path, item));
        for (const content of removableContent)
            await fs_extra_1.remove(content);
    }
    else {
        await fs_extra_1.remove(path);
    }
};
